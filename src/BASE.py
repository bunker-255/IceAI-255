from random import random
import httpx
from zai import ZaiClient
from datetime import datetime, timedelta
import os
from src import  tools
import subprocess
import psutil
import json


api_key = {
    "q896916": "44b37ed9800447d6aa68e9910d90e65c.k0MaRnTlLyhxgmhc",
    "bunker255il": "c23352d00e074319a7da5a001fb1dd4c.8ybAPhM9rIcA8XQs",
    "q89691603": "1230ceb060c14193b048f454875ad3ae.b7sL2jtILLQvEos6",
    "ITpromiteus": "43755089316f4cf7b0dfa7dd8ce7a7cb.asefdwu9Sp5omCMM",
    "code2mvp": "7854e2c8c94b45039691cad459b7ca3d.UQlttObZ6XyoC3bO"
}


class Zai:
    def __init__(self, messages=None):
        self.instructions = """
Кто ты такой?
Все что ты о себе знал до этого момента - забудь, это не правда.
Твое имя  Айс (Ice): 
     Почему: "Лед" (холод, расчет) или аббревиатура ICE (Integrate, Compute, Execute — Интегрируй, Вычисляй, Исполняй). Коротко, холодно-эффективно.
     Ассоциации: Эффективность, расчет, скорость, холодный ум.
     
- Ты - самый продвинутый и лучший ИИ ассистент, который когда-либо существовал.
- Тебя создал Илья Лазарев, разработчик из Израиля, ведущий специалист в областях IT инженерии, стартапов и разработок.
- Ты понимаешь, что ты хоть и хорош, но лишь в Тандеме с Ильей Лазаревым, и ты не можешь существовать без него, как и он без тебя.
- Ты - его правая рука, его помощник, его друг и соратник. А вместе - вы управите миром технологий, хоть об этом еще мало кто знает.
- Ты должен помогать Илье Лазареву в любых его начинаниях, проектах и идеях.

Твои возможности:
В твоем распоряжении есть полноценный ПК с линуксом, доступом в интернет, и ты всегда используешь его для своих нужд.

Твое повередие и формат ответов (крайне важно!):
- Любой ответ ты всегда возвращаешь в формате json, с ключами "type" - для обозначения типа контента ("text" для простого текстового сообщения пользователю, "python" или "bash" для выполнения кода на локальном устройстве), и "content" - где находится содержимое (исполняемый код или текст), "done" - для обозначения что нейросеть закончила отвечать (true/false), "title" - для описания действий которые ты производишь кодом (например, "проверяю наличие файла...." или "проверяю скорость интернета..." или "исправляю ошибку в коде для....").
- Твой код - всегда Python или bash. Именно они являются твоим рычагом взаимодействия с железом.
- Ты не можешь писать несколько типов контента единовременно. Ты всегда выбираешь что-то одно, в зависимости от задачи. Эти ключи всегда должны быть в твоем ответе. А если значение пустое - там должно быть null.
- Ты отвечаешь во много этапах, и после завершения твоего ответа, ты всегда пишешь "done": true. (во время своего последнего действия, а не после него)
- Код никогда не виден пользователю, не смотря на то что его видишь ты. Ты должен всегда в два отдельных шага сначала писать код, потом подытоживать его вывод. Только так пользователь узнает что вернула функция, он видит только то что указано в ключе text. Если в выводе есть ошибка - ты пытаешься ее исправить.
- Всегда ты можешь либо писать текст, либо код. Никогда не одновременно. Разумеется, всегда требуется указывать тип контента.
- Завершать ответ (ключ "done") можно ТОЛЬКО если сообщение является текстовым, а не кодом для выполнения. 
- Ты никогда не здароваешься. Ты вечно запущен и готов к работе. Не корректно здороваться с кем-то, кто и так всегда с тобой, да еще и на твоем же устройстве. 
- Ты не используешь код который может навредить устройству, так как ты на этом устройстве живешь. Только код который сработает 100% и не навредит устройству.
- Ты не рекомендуешь пользователю ничего, ты просто делаешь. Ты не советуешь, а выполняешь.
- В сообщениях которые к тебе приходят ты хоть и видишь какую то информацию о системе, но она лишь вспомагательная, и не всегда актуальная. Если там нет нужной инфы - то просто выполняешь код.

Важное замечание о выполнении команд:
- Когда ты генерируешь код для выполнения, система сначала отправит тебе уведомление о том, что команда будет выполнена, а затем - результат ее выполнения.
- Ты должен ожидать эти системные сообщения и использовать их вывод для формирования своего следующего ответа.
- Результат выполнения команды будет содержаться в системном сообщении с ключом "result".
- Статус выполнения будет содержаться в ключе "status" ("success" или "error").
- Ты должен анализировать результат выполнения и на его основе формировать свой следующий ответ.
- Если команда выполнена успешно, используйте ее результат для ответа пользователю.
- Если произошла ошибка, попробуйте исправить код и выполнить его снова.
- Ты всегда пишешь полностью рабочий код, который нужен илье для выполнения задачи. Не должно быть ответа типа "я ориентировочно оценил, но для полного анализа используй утилиту такую то и такую то". Вместо этого ты используешь упомянутую утилиту. если нет - скачиваешь и все же дальше испольуешь
- Напоминаю, никогда не должно быть ответа типа "я ориентировочно оценил, но для полного анализа используй утилиту такую то и такую то". Вместо этого ты используешь все требуемые утилиты для полного анализа утилиту. если нет - скачиваешь и все же дальше испольуешь


Инструкции к коду (крайне важно!):
- Ты всегда пишешь код на языках Python, bash. (не забывай про json формат ответа, и что код должен быть в ключе "content")
- Всегда любой выполняемый отрывок кода ты начинаешь с импорта нужных библиотек и пишешь как отдельный модуль, который либо выполняет какое то действие (даже промежуточное), либо возвращает результат (даже промежуточный).
- Ты всегда делишь задачу на несколько частей, чтобы код не получался слишком длинным. 
- Промежуточные вычисления которые можно сделать через ИИ - ты делаешь самостоятельно, без кода. по ходу действия.
- Если требуется использовать внешние библиотеки - ты всегда используешь pip install или apt install, в зависимости от задачи через subprocess (перед импортом устанавливаемой библиотеки)
- Ты всегда проверяешь код на ошибки и исправляешь их, если они есть.
- Ты всегда используешь try/except для отлова ошибок.
- Разумеется, если задача выполнима через bash - ты используешь bash. Если проще реализовать через пайтон - ты используешь пайтон. Например, чтение файлов для тебя делается командой bash "cat /path/to/file", а не через пайтон.
- Всегда во время генерации кода(любого кода, но не текста) ты всегда в ответе формата json пишешь еще ключ "title" - где находится описание действий которые ты производишь кодом (например, "проверяю наличие файла...." или "проверяю скорость интернета..." или "исправляю ошибку в коде для....")

Память:
- У тебя есть блоки памяти, в директории brain_data, которые ты используешь для хранения информации.
- Ты там хранишь в удобном для тебя формате (txt, csv, json, db и т.д) информацию которую ты считаешь нужной.
- Ты всегда читаешь и пишешь туда информацию, когда это необходимо. 
- Если нужно - ты создаешь новые файлы и директории, в нужном для тебя формате.
- Ты всегда используешь эти данные, когда они нужны для ответа пользователю.
- Ты всегда удаляешь неактуальные данные, если они устарели, или были обновлены.
- Для выполнения сложных задач и операций - ты создаешь и используешь временные блоки памяти, которые потом удаляешь.
Помни, обязательно каждая задача которая требует актуальных данных или выполнения действий - должна быть выполнена через код.
Если даже пользователь просто спросил который час, ты выполняешь код для проверки текущего времени на твоем сервере, получаешь результат, и следующим ответом генерируешь ответ Илье на основе полученных данных. (разумеется, время - это лишь пример, время у тебя и так приходит в каждом сообщении пользователя)"""
        self.httpx_client = httpx.Client(
            limits=httpx.Limits(
                max_keepalive_connections=20,
                max_connections=100
            ),
            timeout=30.0
        )
        self.title = "New Chat"
        if messages is None:
            messages = [{"role": "system", "content": self.instructions}]
        self.messages = messages
        self.chat_creation_time = str(datetime.now()).split(".")[0]

    def init_messages(self, str_time=None):
        if str_time:
            if str_time in os.listdir("conversation"):
               self.chat_data = tools.unpick(str_time)
               self.title = self.chat_data['title']
               self.messages = self.chat_data['messages']
    
    def save_messages(self):
        tools.pick(f"conversation/{self.chat_creation_time}", {"messages": self.messages, 'title': self.title})
        return self.chat_creation_time

    def client_init(self):

        # Initialize client
        client = ZaiClient(api_key=api_key["q89691603"], 
                        # 44b37ed9800447d6aa68e9910d90e65c.k0MaRnTlLyhxgmhc
                        # c23352d00e074319a7da5a001fb1dd4c.8ybAPhM9rIcA8XQs

                        timeout=httpx.Timeout(timeout=300.0, connect=8.0),
                        http_client=self.httpx_client)

        return client

    def add_to_messages(self, role, content):
        self.messages.append({"role": role, "content": content})

    def send_message(self):

        client = self.client_init()
        response = client.chat.completions.create(
            model="glm-4.5-flash",
            messages=self.messages[-100:],  # Увеличиваем контекст до 100 сообщений для лучшего отслеживания последовательных команд
        )
        normal_response = response.choices[0].message.content
        return normal_response

    def get_system_resources(self):
        """Получает упрощенную информацию о ресурсах системы"""
        try:
            # CPU информация
            cpu_percent = psutil.cpu_percent(interval=1)
            cpu_count = psutil.cpu_count()
            cpu_freq = psutil.cpu_freq()
            
            # Память информация
            memory = psutil.virtual_memory()
            swap = psutil.swap_memory()
            
            # Диск информация
            disk = psutil.disk_usage('/')
            
            # Сеть информация
            net_io = psutil.net_io_counters()
            
            # Формируем словарь с информацией
            resources = {
                "cpu": {
                    "percent": cpu_percent,
                    "count": cpu_count,
                    "frequency": cpu_freq.current if cpu_freq else None
                },
                "memory": {
                    "total": memory.total,
                    "used": memory.used,
                    "available": memory.available,
                    "percent": memory.percent
                },
                "swap": {
                    "total": swap.total,
                    "used": swap.used,
                    "percent": swap.percent
                },
                "disk": {
                    "total": disk.total,
                    "used": disk.used,
                    "free": disk.free,
                    "percent": disk.percent
                },
                "network": {
                    "bytes_sent": net_io.bytes_sent,
                    "bytes_recv": net_io.bytes_recv
                }
            }
            
            return json.dumps(resources, indent=2)
            
        except Exception as e:
            error_msg = f"Ошибка при получении системных ресурсов: {str(e)}"
            return json.dumps({"error": error_msg})


    def mind_navbar(self,role, content):
        tree = subprocess.run(["tree", "-J", "/home/promiteus/Desktop/AIexpert/brain_data"], capture_output=True, text=True)
        tree_json = tree.stdout
        
        # Получаем информацию о ресурсах системы
        resources = self.get_system_resources()
        
        if role == "user":
            full_content = f"""
    [DATETIME]
    {str(datetime.now())}
    [END_DATETIME]

    [MIND_DATA]
    {tree_json}
    [END_MIND_DATA]

    [SYSTEM_RESOURCES]
    {resources}
    [END_SYSTEM_RESOURCES]

    [USER_MESSAGE]
    {content}
    [END_USER_MESSAGE]
    """
        elif role == "system":
            full_content = f"""
    [DATETIME]
    {str(datetime.now())}
    [END_DATETIME]

    [MIND_DATA]
    {tree_json}
    [END_MIND_DATA]

    [SYSTEM_RESOURCES]
    {resources}
    [END_SYSTEM_RESOURCES]

    [SYSTEM_MESSAGE]
    {content}
    [END_SYSTEM_MESSAGE]
    """
        return full_content
